# 동적 계획법

### 최초 작성일 : 2025-04-16
### 최초 작성시간 : 18:44
### 최초 작성자 : 장성환
### 작성 목적 : 동적 게획법 개념 정리

---

### 마지막 수정일 : 2025-04-16
### 마지막 수정시간 : 20:48
### 마지막 작성자 : 장성환

---

### 수정이력

2025-04-16
1. 위치 변경
2. 넘버링 변경

---

### 자료 출처

[동적 계획법](https://velog.io/@hhak3504/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-%EC%A0%95%EB%A6%AC#1-%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-%EA%B0%9C%EB%85%90)

---

## 1. 동적 계획법 개념

- 동적 계획법: 전체 문제를 한 번에 해결하는 것이 아니라, 작은 부분 문제들을 해결하고 이들을 활용해 전체 문제를 해결하는 방법.

### 동적 계획법을 효율적으로 활용하기 위한 조건

- 부분 문제가 겹친다: 큰 문제를 작은 문제로 나누었을 때 동일한 작은 문제가 반복해서 등장해야 함.
- 최적 부분 구조: 이미 푼 부분 문제의 해를 활용해 뒤의 부분 문제를 풀 수 있어야 함.
- 문제 해결법의 합성: 큰 문제의 해결책은 작은 문제의 해결책의 합으로 구성할 수 있어야 함.

---

## 2. 점화식 세우기와 동적 계획법

- 문제를 해결하는 해가 이미 있다고 가정하고, 이를 바탕으로 종료 조건과 점화식을 설정.

### 예시: 팩토리얼 (Factorial)

- Fact(N)을 반환하는 함수가 있을 때
    - 종료 조건: Fact(N) = 1일 때 종료
    - 점화식: Fact(N) = Fact(N-1) * N (N > 1)
    - Fact(1) = 1 (N = 1)
```java
public class Factorial {
    public static int fact(int N) {
        if (N == 1) return 1;  // 종료 조건
        else return fact(N - 1) * N;  // 점화식
    }
}
```

### 재귀 호출에서 발생할 수 있는 문제와 해결 방법

- 재귀 호출 자체를 쓰지 않는 방법: 반복문으로 대체.
- 재귀 호출의 횟수를 줄이는 방법: 메모이제이션(Memoization)을 사용하여 이미 계산한 값을 저장하고 재사용.

---

## 3. 재귀 호출의 횟수를 줄여주는 메모이제이션

- 메모이제이션: 이미 계산한 값을 저장해두고, 이후 같은 계산이 필요할 때 반복하지 않도록 하는 기법.

### 예시: 피보나치 수열

- 메모이제이션을 위한 저장소: 이미 구한 값을 저장할 공간을 준비.
- 재귀 함수 정의: 점화식을 재귀로 표현한 함수 정의.
- 종료 조건: 예를 들어 피보나치 수열의 첫 번째, 두 번째 수는 이미 정해져 있으므로, 이를 메모이제이션 배열에 미리 저장.
- 일반 연산 처리: 동적 계획법에서는 점화식으로 나머지 문제를 처리하며, 이 과정에서 구한 결과를 메모이제이션 배열에 저장.
```java
public class Fibonacci {
    static int[] fibodata = new int[100];  // 메모이제이션을 위한 배열 선언, 0으로 초기화

    public static int fibo(int N) {
        if (fibodata[N] != 0) return fibodata[N];  // 메모이제이션 활용
        if (N <= 2) fibodata[N] = 1;  // 종료 조건
        else fibodata[N] = fibo(N - 1) + fibo(N - 2);  // 점화식
        return fibodata[N];  // 계산된 값을 반환
    }
}
```