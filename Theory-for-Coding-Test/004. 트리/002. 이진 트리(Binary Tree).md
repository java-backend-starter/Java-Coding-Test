# 이진 트리

### 최초 작성일 : 2025-04-14
### 최초 작성시간 : 15:52
### 최초 작성자 : 장성환
### 작성 목적 : 이진 트리 개념 정리

---

### 마지막 수정일 : 2025-04-16
### 마지막 수정시간 : 20:43
### 마지막 작성자 : 장성환

---

### 수정이력

2025-04-16
1. 위치 변경
2. 넘버링 변경

---

### 자료 출처

[이진 트리](https://velog.io/@dlgosla/CS-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC-Binary-Tree-vzdhb2sp#2-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%ACbinary-search-tree-bst)

---


## 1. 이진 트리 (Binary Tree)

- 정의: 노드가 최대 두 개의 자식 노드를 가지는 트리 구조
- 이진 트리의 종류

| 이름             | 설명                                                   |
|------------------|--------------------------------------------------------|
| 포화 이진 트리   | 모든 노드가 0개 또는 2개의 자식을 가지며, 리프는 같은 레벨 |
| 완전 이진 트리   | 마지막 레벨 제외 모두 채워짐, 마지막은 왼쪽부터 채움    |
| 정 이진 트리     | 모든 노드가 0개 또는 2개의 자식만 가짐                   |
| 편향 이진 트리   | 한쪽 방향으로만 자식 노드를 가짐                         |

---

## 2. 이진 탐색 트리 (Binary Search Tree, BST)

- 조건: 왼쪽 자식 < 부모 < 오른쪽 자식
- 시간복잡도

| 연산       | 평균      | 최악 (편향 트리) |
|------------|-----------|------------------|
| 탐색       | O(log n)  | O(n)             |
| 삽입/삭제  | O(log n)  | O(n)             |

- 문제점: 삽입 순서에 따라 트리 구조가 편향되어 성능 저하 가능

### 트리 순회 방식 (Tree Traversal)

- 트리의 노드를 방문하는 순서를 정의하는 방식
- 예시 트리 구조
```
        8
       / \
      3   10
     / \    \
    1   6    14
       / \   /
      4   7 13
```

#### 전위 순회 (Preorder Traversal)

- 방문 순서: 루트 → 왼쪽 자식 → 오른쪽 자식
- 결과: `8 → 3 → 1 → 6 → 4 → 7 → 10 → 14 → 13`
- 특징: 트리 구조를 복사하거나 표현할 때 사용

#### 중위 순회 (Inorder Traversal)

- 방문 순서: 왼쪽 자식 → 루트 → 오른쪽 자식
- 결과: `1 → 3 → 4 → 6 → 7 → 8 → 10 → 13 → 14`
- 특징: 이진 탐색 트리(BST)의 경우 오름차순 정렬된 결과를 얻을 수 있음

#### 후위 순회 (Postorder Traversal)

- 방문 순서: 왼쪽 자식 → 오른쪽 자식 → 루트
- 결과: `1 → 4 → 7 → 6 → 3 → 13 → 14 → 10 → 8`
- 특징: 디렉토리 삭제 등 후처리 연산이나 트리 삭제에 유용

---

## 3. 균형 이진 트리 (Balanced Binary Tree)

- 정의: 모든 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이가 일정 범위 이하로 유지되는 이진 트리
- 일반적으로 허용되는 높이 차이: 1 이하 (구체적인 조건은 구현에 따라 다름)

- 특징:
  - 탐색, 삽입, 삭제 연산에서 $O(log n)$ 시간복잡도 유지 가능
  - 트리의 높이를 최소화하여 성능 유지

- 대표적인 예시:
  - AVL 트리: 모든 노드에서 왼/오 높이 차이 ≤ 1
  - 레드-블랙 트리: 완화된 균형 조건을 가진 이진 탐색 트리

### AVL 트리 (Adelson-Velsky and Landis Tree)

- 조건: 모든 노드에서 왼쪽/오른쪽 서브트리의 높이 차이 ≤ 1
- 삽입/삭제 시 회전으로 균형 조정
- 회전 종류: LL, RR, LR, RL
- 시간복잡도

| 연산       | 평균 & 최악 |
|------------|-------------|
| 탐색       | O(log n)    |
| 삽입/삭제  | O(log n)    |

- 장점
  - 항상 O(log n)의 성능 유지
  - 탐색 성능 우수
- 단점
  - 삽입/삭제 시 회전 연산이 많음
  - 구현이 복잡
- 사용 예시: 읽기 위주 애플리케이션 (검색 시스템 등)

### 레드-블랙 트리 (Red-Black Tree)

- 조건:
    1. 노드는 Red 또는 Black
    2. 루트는 Black
    3. 모든 리프(NIL)는 Black
    4. Red 노드는 자식이 모두 Black
    5. 루트~리프 경로의 Black 노드 수는 같아야 함
- 회전 수: AVL보다 적음 
- 시간복잡도

| 연산       | 평균 & 최악 |
|------------|-------------|
| 탐색       | O(log n)    |
| 삽입/삭제  | O(log n)    |

- 장점
  - 삽입/삭제 성능이 우수
  - 트리 높이가 최대 $2 * log n$ 이내로 제한됨
- 단점
  - AVL보다 탐색 성능은 약간 떨어짐
- 사용 예시: 삽입/삭제 빈번한 시스템 (STL map/set, TreeMap, 리눅스 커널 등)

---

## 4. AVL vs 레드-블랙 트리 비교

| 항목             | AVL Tree                          | Red-Black Tree                    |
|------------------|------------------------------------|-----------------------------------|
| 균형 조건        | 높이 차이 ≤ 1                     | Red 연속 금지 + Black 수 균형 유지 |
| 균형 엄격도      | 높음                               | 낮음                              |
| 탐색 속도        | 빠름                               | 약간 느림                         |
| 삽입/삭제 성능   | 느림 (회전 많음)                  | 빠름 (회전 적음)                 |
| 회전 수          | 많음 (O(log n))                   | 적음 (평균적으로 O(1)~O(log n))  |
| 구현 난이도      | 높음                               | 상대적으로 낮음                  |
| 사용 적합 상황   | 탐색 위주 (읽기 빈번)             | 삽입/삭제 빈번                   |
| 사용 예시        | DB 인덱스, 검색 구조              | STL, TreeMap, 커널 구조체        |
