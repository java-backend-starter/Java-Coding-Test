# 최소 공통 조상

### 최초 작성일 : 2025-04-16
### 최초 작성시간 : 17:27
### 최초 작성자 : 장성환
### 작성 목적 : 최소 공통 조상 개념 정리

---

### 마지막 수정일 : 2025-04-16
### 마지막 수정시간 : 20:44
### 마지막 작성자 : 장성환

---

### 수정이력

2025-04-16
1. 위치 변경
2. 넘버링 변경

2025-04-16
1. 코드 추가

---

### 자료 출처

[Daniel's blog](https://danielcs.tistory.com/46)

[철학과 학생의 개발자 도전기 - 최소 공통 조상 (LCA)](https://philosophy-coding.tistory.com/99)

[My life story - 최소 공통 조상 (LCA, Lowest Common Ancestor)(C/C++)](https://kibbomi.tistory.com/201)

[뉴딜의 서랍장 - Heavy-Light Decomposition 알고리즘](https://newdeal123.tistory.com/28)

[Java로 구현한 LCA 알고리즘 예시](https://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-tree/)

[Do It! 알고리즘 코딩테스트 자바 편](https://search.shopping.naver.com/book/catalog/32490707452?query=Do%20It%21%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EC%9E%90%EB%B0%94%20%ED%8E%B8&NaPm=ct%3Dm8b0153k%7Cci%3D5941797f40bf60f0ca6c9fa49de0d725ca77fca0%7Ctr%3Dboksl%7Csn%3D95694%7Chk%3De2a8eedcf7bdbd8fec6986b9ff8bfaaa587fdd6a)

---

## 1. LCA의 정의

- 최소 공통 조상(LCA)는 트리에서 두 노드가 공통으로 가지는 조상 중에서 가장 깊은(가장 가까운) 조상을 의미합니다. 
- 예를 들어, 트리에서 노드 5와 노드 6의 LCA는 두 노드가 공통으로 가지는 조상 중 가장 깊은 노드입니다.

---

## 2. LCA를 구하는 다양한 방법과 시간 복잡도

### 부모 포인터 방식 (Naive Approach)

- 방법:
    - DFS 또는 BFS를 통해 각 노드의 부모와 깊이를 기록한 후, 두 노드의 깊이를 맞추고 위로 올라가면서 공통 조상을 찾습니다.
- 시간 복잡도:
    - 전처리: O(N)
    - 쿼리: O(H) (H는 트리의 높이)
- 특징:
    - 구현이 간단하지만, 트리의 높이가 클 경우 비효율적일 수 있습니다.

### Binary Lifting (희소 테이블 방식)

- 방법
    - 각 노드에 대해 `2^k`번째 조상을 미리 계산하여 저장한 후, 쿼리 시 두 노드의 깊이를 맞추고 동시에 올라가면서 공통 조상을 찾습니다.
- 시간 복잡도
    - 전처리: O(N log N)
    - 쿼리: O(log N)
- 특징
    - 트리의 높이에 관계없이 효율적으로 LCA를 찾을 수 있습니다.

### 3. 오일러 투어 + 세그먼트 트리 방식

- 방법
    - 트리를 오일러 투어로 변환하여 각 노드의 방문 순서를 기록하고, 세그먼트 트리를 이용해 최소 깊이를 가진 노드를 찾아 LCA를 구합니다.
- 시간 복잡도
    - 전처리: O(N log N)
    - 쿼리: O(log N)
- 특징
    - 구현이 복잡하지만, 다양한 트리 쿼리에 활용할 수 있습니다.

---

## 3. 자바 코드로 구현한 LCA 알고리즘

### 부모 포인터 방식

```java
import java.io.*;
import java.util.*;

public class LCA {
  static ArrayList<ArrayList<Integer>> tree = new ArrayList<>();
  static int [] depth;
  static int [] parent;
  static boolean [] visited;

  static int lca(int a, int b){
    if(depth[a] < depth[b]){
      int temp = a;
      a = b;
      b = temp;
    }
    while(depth[a] != depth[b]){
      a = parent[a];
    }
    while(a != b){
      a = parent[a];
      b = parent[b];
    }
    return a;
  }

  static void BFS(int node){
    Queue<Integer> queue = new LinkedList<>();
    queue.add(node);
    visited[node] = true;

    int level = 1;
    int nowSize = 1;
    int count = 0;
    while(!queue.isEmpty()){
      int now = queue.poll();
      for(int next : tree.get(now)){
        if(!visited[next]){
          visited[next] = true;
          queue.add(next);
          parent[next] = now;
          depth[next] = level;
        }
      }
      count++;
      if(count == nowSize){
        count = 0;
        nowSize = queue.size();
        level++;
      }
    }
  }
  public static void main(String [] args) throws IOException{
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
    StringTokenizer st;

    int node = Integer.parseInt(br.readLine());
    depth = new int[node+1];
    parent = new int[node+1];
    visited = new boolean[node+1];
    for(int i = 0; i <= node; i++){
      tree.add(new ArrayList<>());
    }

    for(int i = 0; i < node-1; i++){
      st = new StringTokenizer(br.readLine());
      int u = Integer.parseInt(st.nextToken());
      int v = Integer.parseInt(st.nextToken());
      tree.get(u).add(v);
      tree.get(v).add(u);
    }

    int query = Integer.parseInt(br.readLine());

    BFS(1);

    for(int i = 0; i < query; i++){
      st = new StringTokenizer(br.readLine());
      int a = Integer.parseInt(st.nextToken());
      int b = Integer.parseInt(st.nextToken());
      bw.write(lca(a, b) + "\n");
    }
    bw.flush();
  }
}
```

다음은 Binary Lifting 방식을 이용한 LCA 알고리즘을 자바로 구현한 예시입니다.

```java
import java.util.*;

public class LCA {
    static final int MAX = 20;  // 트리 높이의 최대값
    static int[][] parent = new int[100000][MAX];
    static int[] depth = new int[100000];
    
    // 트리 그래프
    static ArrayList<Integer>[] tree = new ArrayList[100000];
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int N = sc.nextInt();  // 노드의 수
        int M = sc.nextInt();  // 쿼리 수
        
        // 트리 초기화
        for (int i = 0; i < N; i++) tree[i] = new ArrayList<>();
        
        // 트리의 간선 입력
        for (int i = 0; i < N - 1; i++) {
            int u = sc.nextInt();
            int v = sc.nextInt();
            tree[u].add(v);
            tree[v].add(u);
        }
        
        // DFS로 부모와 깊이를 구하기
        dfs(0, -1, 0);
        
        // Binary Lifting 준비
        prepareLCA(N);
        
        // 쿼리 처리
        for (int i = 0; i < M; i++) {
            int u = sc.nextInt();
            int v = sc.nextInt();
            System.out.println(LCA(u, v));
        }
        
        sc.close();
    }
    
    // DFS를 이용한 부모와 깊이 구하기
    static void dfs(int node, int par, int dep) {
        parent[node][0] = par;
        depth[node] = dep;
        
        for (int next : tree[node]) {
            if (next != par) {
                dfs(next, node, dep + 1);
            }
        }
    }
    
    // Binary Lifting 준비
    static void prepareLCA(int N) {
        for (int j = 1; j < MAX; j++) {
            for (int i = 0; i < N; i++) {
                if (parent[i][j - 1] != -1) {
                    parent[i][j] = parent[parent[i][j - 1]][j - 1];
                }
            }
        }
    }
    
    // LCA 구하기
    static int LCA(int u, int v) {
        if (depth[u] < depth[v]) {
            int temp = u;
            u = v;
            v = temp;
        }
        
        // 깊이 맞추기
        for (int i = MAX - 1; i >= 0; i--) {
            if (depth[u] - (1 << i) >= depth[v]) {
                u = parent[u][i];
            }
        }
        
        if (u == v) return u;
        
        // 두 노드가 동일할 때까지 올라가기
        for (int i = MAX - 1; i >= 0; i--) {
            if (parent[u][i] != parent[v][i]) {
                u = parent[u][i];
                v = parent[v][i];
            }
        }
        
        return parent[u][0];
    }
}
```

### 설명

- DFS로 트리의 부모와 깊이를 구한 후, Binary Lifting 방식을 이용해 2^k번째 조상을 미리 계산합니다.
- 각 쿼리마다 두 노드의 LCA를 구할 때, 깊이를 맞추고 2^k번째 조상을 활용해 두 노드를 동시에 올라가며 공통 조상을 찾습니다.