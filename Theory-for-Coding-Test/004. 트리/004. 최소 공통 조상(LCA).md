# 최소 공통 조상

### 최초 작성일 : 2025-04-16
### 최초 작성시간 : 17:27
### 최초 작성자 : 장성환
### 작성 목적 : 최소 공통 조상 개념 정리

---

### 마지막 수정일 : 2025-04-16
### 마지막 수정시간 : 20:44
### 마지막 작성자 : 장성환

---

### 수정이력

2025-04-16
1. 위치 변경
2. 넘버링 변경

---

### 자료 출처

[Daniel's blog](https://danielcs.tistory.com/46)

[철학과 학생의 개발자 도전기 - 최소 공통 조상 (LCA)](https://philosophy-coding.tistory.com/99)

[My life story - 최소 공통 조상 (LCA, Lowest Common Ancestor)(C/C++)](https://kibbomi.tistory.com/201)

[뉴딜의 서랍장 - Heavy-Light Decomposition 알고리즘](https://newdeal123.tistory.com/28)

[Java로 구현한 LCA 알고리즘 예시](https://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-tree/)

---

## 1. LCA의 정의

- 최소 공통 조상(LCA)는 트리에서 두 노드가 공통으로 가지는 조상 중에서 가장 깊은(가장 가까운) 조상을 의미합니다. 
- 예를 들어, 트리에서 노드 5와 노드 6의 LCA는 두 노드가 공통으로 가지는 조상 중 가장 깊은 노드입니다.

---

## 2. LCA를 구하는 다양한 방법과 시간 복잡도

### 부모 포인터 방식 (Naive Approach)

- 방법:
    - DFS를 통해 각 노드의 부모와 깊이를 기록한 후, 두 노드의 깊이를 맞추고 위로 올라가면서 공통 조상을 찾습니다.
- 시간 복잡도:
    - 전처리: O(N)
    - 쿼리: O(H) (H는 트리의 높이)
- 특징:
    - 구현이 간단하지만, 트리의 높이가 클 경우 비효율적일 수 있습니다.

### Binary Lifting (희소 테이블 방식)

- 방법
    - 각 노드에 대해 `2^k`번째 조상을 미리 계산하여 저장한 후, 쿼리 시 두 노드의 깊이를 맞추고 동시에 올라가면서 공통 조상을 찾습니다.
- 시간 복잡도
    - 전처리: O(N log N)
    - 쿼리: O(log N)
- 특징
    - 트리의 높이에 관계없이 효율적으로 LCA를 찾을 수 있습니다.

### 3. 오일러 투어 + 세그먼트 트리 방식

- 방법
    - 트리를 오일러 투어로 변환하여 각 노드의 방문 순서를 기록하고, 세그먼트 트리를 이용해 최소 깊이를 가진 노드를 찾아 LCA를 구합니다.
- 시간 복잡도
    - 전처리: O(N log N)
    - 쿼리: O(log N)
- 특징
    - 구현이 복잡하지만, 다양한 트리 쿼리에 활용할 수 있습니다.

---

## 3.? 자바 코드로 구현한 LCA 알고리즘

다음은 Binary Lifting 방식을 이용한 LCA 알고리즘을 자바로 구현한 예시입니다.

```java
import java.util.*;

public class LCA {
    static final int MAX = 20;  // 트리 높이의 최대값
    static int[][] parent = new int[100000][MAX];
    static int[] depth = new int[100000];
    
    // 트리 그래프
    static ArrayList<Integer>[] tree = new ArrayList[100000];
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int N = sc.nextInt();  // 노드의 수
        int M = sc.nextInt();  // 쿼리 수
        
        // 트리 초기화
        for (int i = 0; i < N; i++) tree[i] = new ArrayList<>();
        
        // 트리의 간선 입력
        for (int i = 0; i < N - 1; i++) {
            int u = sc.nextInt();
            int v = sc.nextInt();
            tree[u].add(v);
            tree[v].add(u);
        }
        
        // DFS로 부모와 깊이를 구하기
        dfs(0, -1, 0);
        
        // Binary Lifting 준비
        prepareLCA(N);
        
        // 쿼리 처리
        for (int i = 0; i < M; i++) {
            int u = sc.nextInt();
            int v = sc.nextInt();
            System.out.println(LCA(u, v));
        }
        
        sc.close();
    }
    
    // DFS를 이용한 부모와 깊이 구하기
    static void dfs(int node, int par, int dep) {
        parent[node][0] = par;
        depth[node] = dep;
        
        for (int next : tree[node]) {
            if (next != par) {
                dfs(next, node, dep + 1);
            }
        }
    }
    
    // Binary Lifting 준비
    static void prepareLCA(int N) {
        for (int j = 1; j < MAX; j++) {
            for (int i = 0; i < N; i++) {
                if (parent[i][j - 1] != -1) {
                    parent[i][j] = parent[parent[i][j - 1]][j - 1];
                }
            }
        }
    }
    
    // LCA 구하기
    static int LCA(int u, int v) {
        if (depth[u] < depth[v]) {
            int temp = u;
            u = v;
            v = temp;
        }
        
        // 깊이 맞추기
        for (int i = MAX - 1; i >= 0; i--) {
            if (depth[u] - (1 << i) >= depth[v]) {
                u = parent[u][i];
            }
        }
        
        if (u == v) return u;
        
        // 두 노드가 동일할 때까지 올라가기
        for (int i = MAX - 1; i >= 0; i--) {
            if (parent[u][i] != parent[v][i]) {
                u = parent[u][i];
                v = parent[v][i];
            }
        }
        
        return parent[u][0];
    }
}
```

### 설명

- DFS로 트리의 부모와 깊이를 구한 후, Binary Lifting 방식을 이용해 2^k번째 조상을 미리 계산합니다.
- 각 쿼리마다 두 노드의 LCA를 구할 때, 깊이를 맞추고 2^k번째 조상을 활용해 두 노드를 동시에 올라가며 공통 조상을 찾습니다.