# 정수론

### 최초 작성일 : 2025-03-16
### 최초 작성시간 : 11:13
### 최초 작성자 : 장성환
### 작성 목적 : 정수론 개념 정리

---

### 마지막 수정일 :
### 마지막 수정시간 :
### 마지막 작성자 :

---

### 수정이력

---

### 자료 출처

[Do It! 알고리즘 코딩테스트 자바 편](https://search.shopping.naver.com/book/catalog/32490707452?query=Do%20It%21%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EC%9E%90%EB%B0%94%20%ED%8E%B8&NaPm=ct%3Dm8b0153k%7Cci%3D5941797f40bf60f0ca6c9fa49de0d725ca77fca0%7Ctr%3Dboksl%7Csn%3D95694%7Chk%3De2a8eedcf7bdbd8fec6986b9ff8bfaaa587fdd6a)

[에라토스테네스의 체1](https://velog.io/@youngjun_10/Algorithm-%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98-%EC%B2%B4)

[에라토스테네스의 체2](https://sihyung92.oopy.io/4e7efa0a-984f-4bc9-bab9-d2c0ac4faa35)

[정수론 : 약수와 배수](https://8iggy.tistory.com/16)

[유클리드 호제법](https://ko.wikipedia.org/wiki/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C_%ED%98%B8%EC%A0%9C%EB%B2%95)

[확장 유클리드 호제법](https://velog.io/@cjy/nkryvnjc)
---

## 1. 에라토스테네스의 체

### 개념

* 에라토스테네스가 만든 소수를 찾는 방법
* 임의의 수 k의 소수의 여부를 확인할 때 k의 제곱근 까지만 약수의 여부를 검증해서 구하는 방식
  * k를 n(k 이하의 수)으로 나누면 몫이 발생하고 몫과 n 둘 중 하나는 n의 제곱근 이하이기 때문에 가능
* 대량의 소수를 한번에 판별해야 할 때 에라토스테네스의 체를 사용하면 빠르게 소수를 판별할 수 있음

### 원리

1. 배열을 생성해서 초기화
2. 2부터 시작해서 임의의 수 a의 배수에 해당하는 수를 모두 지운다
   1. 자기 자신(a)는 지우지 않는다.
   2. 이미 지워진 수는 건너뛴다.
   3. 2를 반복
4. 최종 결과는 소수만 남아 있는다.

![에라토스테네스의 원리](https://velog.velcdn.com/images/youngjun_10/post/a2b854cd-8034-4aa1-bb65-1647c8749d93/image.gif)

### 구현

```java
import java.util.Arrays;

public boolean [] eratostenes(int n){
    boolean [] primes = new boolean[n+1];
    Arrays.fill(primes, true);
    
    primes[0] = false;
    primes[1] = false;
    
    for(int i = 2; i <= Math.sqrt(n); i++){
        if(!primes[i]){
            continue;
        }
        
        for(int j = i*i; j <= n; j += i){
            primes[j] = false;
        }
    }
    
    return primes;
}

public boolean isPrime(int n){
    if(n <= 1 || n % 2 == 0){
        return false;
    }
    
    if(n == 2){
        return true;
    }
    
    for(int i = 3; i <= Math.sqrt(n); i++){
        if(n % i == 0) {
            return false;
        }
    }
    return true;
}
```

### 시간복잡도

* eratostenes 함수의 시간 복잡도는 for문에 의해 결정된다.
  * Arrays.fill : Ο(n)
  * 바깥쪽 for문 : Ο($\sqrt{n}$)
  * 안쪽 for문 : Ο($\dfrac{n}{i}$)
  * 그 외 : Ο(1)
  * for문에 대해서 $\sum_{i=2}^{\sqrt{n}} \dfrac{n}{i}$라는 식을 계산해야 한다.
  * 위의 식을 계산하면 $Ο(n \log \log n)$이라는 계산 결과가 나온다.
    * 
  * 계산 과정은 작성자가 완전히 이해한 것이 아니라서 조화 급수에 대해서 알아보면 된다.
* isPrime의 경우에는 1개의 수에 대해서 소수 여부만 판단하는 것으로 for문의 반복 횟수에 영향을 받는다.
  * for문은 $\sqrt{n}$번 반복되므로 따라서 시간 복잡도는 Ο($\sqrt{n}$)이다.
---

## 2. 유클리드 호제법

### 기본 개념

* 약수와 배수
  * a, d ∈ Z이고 d ≠ 0일 때 a = cd를 만족하는 어떤 정수 c가 있을 때 d는 a의 약수, a는 d의 배수이다.
  * 풀어서 쓰면 두 정수 a와 0이 아닌 d에 대해서 a = cd를 만족시키는 어떤 정수 c가 존재할 때의 a와 d의 관계를 말한다.
  * 약수는 어떤 정수 a에 대해서 a를 나누어 떨어지게 만드는 수이다.
  * 배수는 어떤 정수 a에 다른 정수를 곱하여 얻을 수 있는 값들의 집합이다.
* 최대공약수와 최소공배수
  * 최대공약수는 두 정수 a와 b가 가지는 공통된 약수들 중 최댓값이다.
  * 최소 공배수는 두 정수 a와 b가 가지는 공통된 배수들 중 최솟값이다.

### 유클리드 호제법

* 두 자연수의 최대공약수를 구하는 알고리즘
* 두 자연수 a와 b에 대해서 a를 b로 나눈 나머지가 r일 때 a와 b의 최대 공약수는 b와 r의 최대공약수와 같다는 원리를 사용
* 유클리도 호제법을 구현할 때 MOD 연산으로 구현하며 다음의 과정을 거친다
  1. 큰 수(a)를 작은 수(b)로 나누는 MOD 연산을 수행
  2. 1에서의 작은 수와 MOD 연산으로 나온 나머지로 MOD 연산을 수행
  3. 나머지가 0이 나올 때까지 2를 반복
  4. 3에서 나머지가 0이 나올 때 MOD 연산에 사용된 작은 수가 최대 공약수이다.
* 유클리드 호제법으로 구한 최대 공약수로 최소 공배수를 구할 수 있다.
  * 원리 : 두 수의 곱 = 최대공약수 * 최소공배수 -> 최소 공배수 = 두 수의 곱/최대공약수


--- 

## . 오일러의 피

